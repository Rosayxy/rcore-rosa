# lab5 notes
## 线程
线程是进程的组成部分，进程可包含1 – n个线程，属于同一个进程的线程共享进程的资源， 比如**地址空间、打开的文件**等。基本的线程由线程ID、执行状态、当前指令指针 (PC)、寄存器集合和栈组成    
进程是线程的资源容器， 线程成为了程序的基本执行实体     

在没有线程之前，一个进程在一个时刻只有一个执行点（即程序计数器 (PC) 寄存器保存的要执行指令的指针）。但线程的引入把进程内的这个单一执行点给扩展为多个执行点，即在进程中存在多个线程， 每个线程都有一个执行点。而且这些线程共享进程的地址空间，所以可以不必采用相对比较复杂的 IPC 机制（一般需要内核的介入）， 而可以很方便地直接访问进程内的数据     

sys_thread_create(), 感觉就和以前加进程差不多     
想看 trace 信息就需要加 LOG=TRACE    

sys_wait_id: 进程/主线程要负责通过 waittid 来等待它创建出来的线程（不是主线程）结束并回收它们在内核中的资源 （如线程的内核栈、线程控制块等）    

TaskControlBlockInner 相比于前面的实现有变化，就像是多了 `res: Option<TaskUserRes>` 指出了用户态的线程代码执行需要的信息，这些在线程初始化之后就不再变化    

由于执行谋段汇编代码的多个线程在访问全局变量过程中可能导致竞争状态， 因此我们将此段代码称为临界区    
我们可以建立一种锁， 只有拿到锁的线程才能在临界区中执行    
mutex 实现是轻量级的可睡眠锁    
让等待锁的线程睡眠，让释放锁的线程显式地唤醒等待锁的线程    

**信号量：Semaphore 机制**   
而信号量的初始值可设置为 N 的整数变量, 如果 N 大于 0， 表示最多可以有 N 个线程进入临界区执行，如果 N 小于等于 0 ，表示不能有线程进入临界区了， 必须在后续操作中让信号量的值加 1 ，才能唤醒某个等待的线程     
P 操作和 V 操作：   
P 操作是检查信号量的值是否大于 0，若该值大于 0，则将其值减 1 并继续（表示可以进入临界区了）；若该值为 0，则线程将睡眠，在 P 操作中，检查/修改信号量值以及可能发生的睡眠这一系列操作， 是一个不可分割的原子操作过程    

V 操作会对信号量的值加 1 ，然后检查是否有一个或多个线程在该信号量上睡眠等待，如有， 则选择其中的一个线程唤醒并允许该线程继续完成它的 P 操作；如没有，则直接返回。注意，信号量的值加 1， 并可能唤醒一个线程的一系列操作同样也是不可分割的原子操作过程     

semaphore_up 和 semaphore_down 分别对应 加1/减1 很直接   

条件变量机制：计算机科学家针对某些情况设计了一种更高层的同步互斥原语。具体而言，在有些情况下， 线程需要检查某一条件（condition）满足之后，才会继续执行    
**任一时刻只能有一个活跃线程调用管程中的过程， 这一特性使线程在调用执行管程中过程时能保证互斥**    

线程间沟通：等待机制：由于线程在调用管程中某个过程时，发现某个条件不满足，那就在无法继续运行而被阻塞；唤醒机制：另外一个线程可以在调用管程的过程中，把某个条件设置为真，并且还需要有一种机制， 及时唤醒等待条件为真的阻塞线程     

Mesa 语义：唤醒线程在发出行唤醒操作后继续运行，并且只有它退出管程之后，才允许等待的线程开始运行。 注：此时唤醒线程的执行位置还在管程中    

看上面我们对线程间沟通的需求，**条件变量的wait操作包含三步，1. 释放锁；2. 把自己挂起；3. 被唤醒后，再获取锁。条件变量的 signal 操作只包含一步：找到挂在条件变量上睡眠的线程，把它唤醒**    

enable_deadlock_detect 为当前**进程**启用死锁检测功能，代表这个 flag 要塞到进程里面   
这个资源是指**锁的资源**   
可利用资源向量 Available ：含有 m 个元素的一维数组，每个元素代表可利用的某一类资源的数目， 其初值是该类资源的全部可用数目，其值随该类资源的分配和回收而动态地改变。 Available[j] = k，表示第 j 类资源的可用数量为 k    

分配矩阵 Allocation：n * m 矩阵，表示每类资源已分配给每个线程的资源数。 Allocation[i,j] = g，则表示线程 i 当前己分得第 j 类资源的数量为 g。

需求矩阵 Need：n * m 的矩阵，表示每个线程还需要的各类资源数量。 Need[i,j] = d，则表示线程 i 还需要第 j 类资源的数量为 d   
具体算法看文档    

先不把 sys_get_time 迁移了 orz 不迁的话会在 sleep 挂掉    


所有的数据结构都塞到 ProcessControlBlock 里面吧    

在 semaphore / mutex create 的时候，维护 Avail 数组    
能否现算 Allocation 数组？   

TODO waittid 的时候清空该列   

